#[cfg(feature = "zep-editor")]
use std::ffi::{CStr, CString};
#[cfg(feature = "zep-editor")]
use std::ptr;

#[cfg(feature = "zep-editor")]
use color_eyre::eyre::Result;
#[cfg(feature = "zep-editor")]
use crossterm::event::KeyEvent;
#[cfg(feature = "zep-editor")]
use ratatui::layout::Rect;

#[cfg(feature = "zep-editor")]
use crate::{action::Action, editor_component::EditorComponent};

#[cfg(feature = "zep-editor")]
extern "C" {
  // Zep C++ FFI functions - these will be generated by bindgen
  fn zep_create_editor(root_path: *const std::os::raw::c_char) -> *mut std::os::raw::c_void;
  fn zep_destroy_editor(editor: *mut std::os::raw::c_void);
  fn zep_init_with_text(
    editor: *mut std::os::raw::c_void,
    name: *const std::os::raw::c_char,
    text: *const std::os::raw::c_char,
  );
  fn zep_get_text(editor: *mut std::os::raw::c_void, buffer: *mut std::os::raw::c_char, size: usize) -> usize;
  fn zep_set_vim_mode(editor: *mut std::os::raw::c_void);
  fn zep_handle_key(editor: *mut std::os::raw::c_void, key: u32, modifiers: u32) -> bool;
  fn zep_display(editor: *mut std::os::raw::c_void, x: f32, y: f32, width: f32, height: f32);
}

#[cfg(feature = "zep-editor")]
#[derive(Debug)]
pub struct ZepEditor {
  editor_ptr: *mut std::os::raw::c_void,
  content: String,
  cursor_pos: usize, // Character position in content
  mode: crate::editor_common::Mode,
  visual_start_pos: Option<usize>, // Start position for visual selection
  pending_command: String,         // For multi-key sequences like "cc", "gcc"
}

#[cfg(feature = "zep-editor")]
impl Default for ZepEditor {
  fn default() -> Self {
    Self::new()
  }
}

#[cfg(feature = "zep-editor")]
impl ZepEditor {
  pub fn new() -> Self {
    let root_path = CString::new(".").expect("Failed to create root path CString");
    let editor_ptr = unsafe { zep_create_editor(root_path.as_ptr()) };

    if editor_ptr.is_null() {
      panic!("Failed to create Zep editor");
    }

    // Set to vim mode by default
    unsafe {
      zep_set_vim_mode(editor_ptr);
    }

    Self {
      editor_ptr,
      content: String::new(),
      cursor_pos: 0,
      mode: crate::editor_common::Mode::Normal,
      visual_start_pos: None,
      pending_command: String::new(),
    }
  }

  fn update_content_from_zep(&mut self) {
    // Skip updating from Zep since we're managing content locally for the stub implementation
    // This prevents the "Zep Editor (stub implementation)" text from overriding our content
    // In a real Zep implementation, this would sync content from the C++ editor

    // const BUFFER_SIZE: usize = 1024 * 1024; // 1MB buffer
    // let mut buffer = vec![0u8; BUFFER_SIZE];
    //
    // unsafe {
    //   let actual_size = zep_get_text(self.editor_ptr, buffer.as_mut_ptr() as *mut std::os::raw::c_char, BUFFER_SIZE);
    //   if actual_size > 0 && actual_size < BUFFER_SIZE {
    //     buffer.resize(actual_size, 0);
    //     if let Ok(content) = String::from_utf8(buffer) {
    //       // Only update if it's not the stub text
    //       if !content.contains("stub implementation") {
    //         self.content = content;
    //       }
    //     }
    //   }
    // }
  }

  // Helper methods for cursor movement (since we're using a stub)
  fn get_current_line_start(&self) -> usize {
    if self.content.is_empty() {
      return 0;
    }

    let mut pos = self.cursor_pos.min(self.content.len());

    // Move backwards from current position to find start of line
    while pos > 0 {
      if let Some(ch) = self.content.chars().nth(pos - 1) {
        if ch == '\n' {
          break; // Found newline, pos is at start of current line
        }
      }
      pos -= 1;
    }
    pos
  }

  fn get_current_line_end(&self) -> usize {
    if self.content.is_empty() {
      return 0;
    }

    let mut pos = self.cursor_pos.min(self.content.len());

    // Move forward from current position to find end of line
    while pos < self.content.len() {
      if let Some(ch) = self.content.chars().nth(pos) {
        if ch == '\n' {
          break; // Found newline, pos is at end of current line
        }
      }
      pos += 1;
    }
    pos
  }

  fn move_cursor_to_line_start(&mut self) {
    self.cursor_pos = self.get_current_line_start();
    self.clamp_cursor();
  }

  fn move_cursor_to_line_end(&mut self) {
    self.cursor_pos = self.get_current_line_end();
    self.clamp_cursor();
  }

  fn move_cursor_left(&mut self) {
    if self.cursor_pos > 0 {
      self.cursor_pos -= 1;
    }
  }

  fn move_cursor_right(&mut self) {
    if self.cursor_pos < self.content.len() {
      self.cursor_pos += 1;
    }
  }

  fn move_cursor_up(&mut self) {
    let current_line_start = self.get_current_line_start();
    let current_col = self.cursor_pos - current_line_start;

    if current_line_start > 0 {
      // Find previous line start
      let mut prev_line_end = current_line_start - 1;
      while prev_line_end > 0 && self.content.chars().nth(prev_line_end - 1) != Some('\n') {
        prev_line_end -= 1;
      }
      let prev_line_start =
        if prev_line_end > 0 { self.content[..prev_line_end].rfind('\n').map(|pos| pos + 1).unwrap_or(0) } else { 0 };

      let prev_line_len = current_line_start - 1 - prev_line_start;
      self.cursor_pos = prev_line_start + current_col.min(prev_line_len);
    }
    self.clamp_cursor();
  }

  fn move_cursor_down(&mut self) {
    let current_line_start = self.get_current_line_start();
    let current_col = self.cursor_pos - current_line_start;
    let current_line_end = self.get_current_line_end();

    // Check if there's a next line
    if current_line_end < self.content.len() {
      let next_line_start = current_line_end + 1;
      let next_line_end =
        self.content[next_line_start..].find('\n').map(|pos| next_line_start + pos).unwrap_or(self.content.len());

      let next_line_len = next_line_end - next_line_start;
      self.cursor_pos = next_line_start + current_col.min(next_line_len);
    }
    self.clamp_cursor();
  }

  fn move_cursor_word_forward(&mut self) {
    while self.cursor_pos < self.content.len() {
      let ch = self.content.chars().nth(self.cursor_pos);
      if ch == Some(' ') || ch == Some('\t') || ch == Some('\n') {
        self.cursor_pos += 1;
        break;
      }
      self.cursor_pos += 1;
    }
    // Skip whitespace
    while self.cursor_pos < self.content.len() {
      let ch = self.content.chars().nth(self.cursor_pos);
      if ch != Some(' ') && ch != Some('\t') {
        break;
      }
      self.cursor_pos += 1;
    }
  }

  fn move_cursor_word_backward(&mut self) {
    if self.cursor_pos > 0 {
      self.cursor_pos -= 1;
      // Skip whitespace
      while self.cursor_pos > 0 {
        let ch = self.content.chars().nth(self.cursor_pos);
        if ch != Some(' ') && ch != Some('\t') {
          break;
        }
        self.cursor_pos -= 1;
      }
      // Skip to start of word
      while self.cursor_pos > 0 {
        let ch = self.content.chars().nth(self.cursor_pos - 1);
        if ch == Some(' ') || ch == Some('\t') || ch == Some('\n') {
          break;
        }
        self.cursor_pos -= 1;
      }
    }
  }

  fn delete_char_at_cursor(&mut self) {
    if self.cursor_pos < self.content.len() {
      self.content.remove(self.cursor_pos);
    }
  }

  fn delete_char_before_cursor(&mut self) {
    if self.cursor_pos > 0 {
      self.cursor_pos -= 1;
      self.content.remove(self.cursor_pos);
    }
  }

  fn delete_current_line(&mut self) {
    let line_start = self.get_current_line_start();
    let line_end = self.get_current_line_end();

    // Include the newline character if it exists
    let delete_end = if line_end < self.content.len() { line_end + 1 } else { line_end };

    if line_start < delete_end {
      self.content.drain(line_start..delete_end);
      self.cursor_pos = line_start;
      self.clamp_cursor();
    }
  }

  // Ensure cursor position is always valid
  fn clamp_cursor(&mut self) {
    self.cursor_pos = self.cursor_pos.min(self.content.len());
  }

  // Apply basic syntax highlighting for SQL queries
  fn apply_syntax_highlighting(&self, line_content: &str) -> Vec<ratatui::text::Span<'static>> {
    use ratatui::text::Span;

    use crate::theme::Theme;

    let mut spans = Vec::new();
    let mut current_word = String::new();
    let mut chars = line_content.chars().peekable();

    while let Some(ch) = chars.next() {
      if ch.is_whitespace() || ch == '(' || ch == ')' || ch == ',' || ch == ';' || ch == '.' {
        if !current_word.is_empty() {
          spans.push(self.style_word(&current_word));
          current_word.clear();
        }
        spans.push(Span::raw(ch.to_string()));
      } else if ch == '\'' {
        // String literal
        let mut string_content = String::new();
        string_content.push(ch);
        while let Some(next_ch) = chars.next() {
          string_content.push(next_ch);
          if next_ch == '\'' {
            break;
          }
        }
        spans.push(Span::styled(string_content, Theme::sql_string()));
      } else if ch == '-' && chars.peek() == Some(&'-') {
        // SQL comment
        let mut comment = String::new();
        comment.push(ch);
        comment.push(chars.next().unwrap()); // consume second '-'
                                             // Read rest of line as comment
        while let Some(next_ch) = chars.next() {
          comment.push(next_ch);
        }
        spans.push(Span::styled(comment, Theme::sql_comment()));
        break;
      } else {
        current_word.push(ch);
      }
    }

    if !current_word.is_empty() {
      spans.push(self.style_word(&current_word));
    }

    spans
  }

  fn style_word(&self, word: &str) -> ratatui::text::Span<'static> {
    use ratatui::text::Span;

    use crate::theme::Theme;

    let upper_word = word.to_uppercase();
    let styled_word = match upper_word.as_str() {
      // SQL Keywords
      "SELECT" | "FROM" | "WHERE" | "INSERT" | "UPDATE" | "DELETE" | "CREATE" | "DROP" | "ALTER" | "TABLE"
      | "INDEX" | "VIEW" | "DATABASE" | "SCHEMA" | "JOIN" | "INNER" | "LEFT" | "RIGHT" | "OUTER" | "ON" | "AS"
      | "GROUP" | "BY" | "ORDER" | "HAVING" | "UNION" | "DISTINCT" | "LIMIT" | "OFFSET" | "WITH" | "CASE" | "WHEN"
      | "THEN" | "ELSE" | "END" | "IF" | "EXISTS" | "NOT" | "NULL" | "TRUE" | "FALSE" | "AND" | "OR" => {
        Span::styled(word.to_string(), Theme::sql_keyword())
      },
      // SQL Functions
      "COUNT" | "SUM" | "AVG" | "MIN" | "MAX" | "CONCAT" | "SUBSTRING" | "LENGTH" | "UPPER" | "LOWER" | "TRIM"
      | "NOW" | "DATE" | "TIME" | "YEAR" | "MONTH" | "DAY" => Span::styled(word.to_string(), Theme::sql_function()),
      // Numbers
      _ if word.chars().all(|c| c.is_ascii_digit() || c == '.') => Span::styled(word.to_string(), Theme::sql_number()),
      // Default text
      _ => Span::raw(word.to_string()),
    };

    styled_word
  }

  fn insert_char(&mut self, c: char) {
    self.content.insert(self.cursor_pos, c);
    self.cursor_pos += 1;
  }

  fn delete_char(&mut self) {
    if self.cursor_pos > 0 {
      self.content.remove(self.cursor_pos - 1);
      self.cursor_pos -= 1;
    }
  }

  // Get the content of the current line
  fn get_current_line_content(&self) -> String {
    let line_start = self.get_current_line_start();
    let line_end = self.get_current_line_end();

    if line_start <= line_end && line_end <= self.content.len() {
      self.content[line_start..line_end].to_string()
    } else {
      String::new()
    }
  }

  // Replace the current line content with new content
  fn replace_current_line(&mut self, new_content: &str) {
    let line_start = self.get_current_line_start();
    let line_end = self.get_current_line_end();

    if line_start <= line_end && line_end <= self.content.len() {
      // Replace the line content
      self.content.replace_range(line_start..line_end, new_content);
      // Position cursor at the end of the new content
      self.cursor_pos = line_start + new_content.len();
      self.clamp_cursor();
    }
  }

  // Delete current line content and enter insert mode (for "cc" command)
  fn change_current_line(&mut self) {
    let line_start = self.get_current_line_start();
    let line_end = self.get_current_line_end();

    if line_start <= line_end && line_end <= self.content.len() {
      // Delete line content but keep the line structure
      self.content.replace_range(line_start..line_end, "");
      self.cursor_pos = line_start;
      self.mode = crate::editor_common::Mode::Insert;
    }
  }

  // Toggle comment on current line (for "gcc" command)
  fn toggle_comment_current_line(&mut self) {
    let current_line = self.get_current_line_content();

    // Detect if line is already commented
    let trimmed = current_line.trim_start();
    let is_commented = trimmed.starts_with("--") || trimmed.starts_with("#") || trimmed.starts_with("//");

    let new_content = if is_commented {
      // Remove comment
      if trimmed.starts_with("-- ") {
        current_line.replacen("-- ", "", 1)
      } else if trimmed.starts_with("--") {
        current_line.replacen("--", "", 1)
      } else if trimmed.starts_with("# ") {
        current_line.replacen("# ", "", 1)
      } else if trimmed.starts_with("#") {
        current_line.replacen("#", "", 1)
      } else if trimmed.starts_with("// ") {
        current_line.replacen("// ", "", 1)
      } else if trimmed.starts_with("//") {
        current_line.replacen("//", "", 1)
      } else {
        current_line
      }
    } else {
      // Add SQL comment (since this is a database tool)
      if current_line.trim().is_empty() {
        "-- ".to_string()
      } else {
        format!("-- {}", current_line)
      }
    };

    self.replace_current_line(&new_content);
  }
}

#[cfg(feature = "zep-editor")]
impl Drop for ZepEditor {
  fn drop(&mut self) {
    if !self.editor_ptr.is_null() {
      unsafe {
        zep_destroy_editor(self.editor_ptr);
      }
    }
  }
}

#[cfg(feature = "zep-editor")]
impl EditorComponent for ZepEditor {
  fn init(&mut self, _area: Rect) -> Result<()> {
    // Initialize with empty buffer
    let name = CString::new("query").expect("Failed to create buffer name");
    let text = CString::new(self.content.as_str()).expect("Failed to create text CString");

    unsafe {
      zep_init_with_text(self.editor_ptr, name.as_ptr(), text.as_ptr());
    }

    Ok(())
  }

  fn on_key_event(&mut self, key: KeyEvent) -> Result<Option<Action>> {
    // Enhanced vim-like key handling for better user experience
    match self.mode {
      crate::editor_common::Mode::Normal => {
        // Handle multi-key sequences first
        if let crossterm::event::KeyCode::Char(c) = key.code {
          self.pending_command.push(c);

          // Check for complete commands
          match self.pending_command.as_str() {
            "cc" => {
              self.change_current_line();
              self.pending_command.clear();
              return Ok(Some(crate::action::Action::Render));
            },
            "gcc" => {
              self.toggle_comment_current_line();
              self.pending_command.clear();
              return Ok(Some(crate::action::Action::Render));
            },
            _ => {
              // Check if we have a partial command that could become complete
              if "cc".starts_with(&self.pending_command) || "gcc".starts_with(&self.pending_command) {
                // Wait for more input - don't process single character yet
                if self.pending_command.len() < 3
                  && ((self.pending_command == "c" && c == 'c')
                    || (self.pending_command == "g" && c == 'c')
                    || (self.pending_command == "gc" && c == 'c')
                    || (self.pending_command.len() == 1 && (c == 'c' || c == 'g')))
                {
                  return Ok(None); // Wait for next character
                }
              }

              // Not a recognized multi-key sequence, process as single character
              // Reset pending command and process the current character
              let single_char = self.pending_command.chars().last().unwrap_or(c);
              self.pending_command.clear();

              // Process single character commands
              match single_char {
                // Movement commands
                '0' => {
                  self.move_cursor_to_line_start();
                  return Ok(Some(crate::action::Action::Render));
                },
                '$' => {
                  self.move_cursor_to_line_end();
                  return Ok(Some(crate::action::Action::Render));
                },
                'h' => {
                  self.move_cursor_left();
                  return Ok(Some(crate::action::Action::Render));
                },
                'l' => {
                  self.move_cursor_right();
                  return Ok(Some(crate::action::Action::Render));
                },
                'j' => {
                  self.move_cursor_down();
                  return Ok(Some(crate::action::Action::Render));
                },
                'k' => {
                  self.move_cursor_up();
                  return Ok(Some(crate::action::Action::Render));
                },
                'w' => {
                  self.move_cursor_word_forward();
                  return Ok(Some(crate::action::Action::Render));
                },
                'b' => {
                  self.move_cursor_word_backward();
                  return Ok(Some(crate::action::Action::Render));
                },
                'g' => {
                  // Handle 'gg' for goto first line (simplified)
                  self.cursor_pos = 0;
                  return Ok(Some(crate::action::Action::Render));
                },
                'G' => {
                  // Goto last line
                  self.cursor_pos = self.content.len();
                  return Ok(Some(crate::action::Action::Render));
                },

                // Insert mode commands
                'i' => {
                  self.mode = crate::editor_common::Mode::Insert;
                  return Ok(Some(crate::action::Action::Render));
                },
                'I' => {
                  self.move_cursor_to_line_start();
                  self.mode = crate::editor_common::Mode::Insert;
                  return Ok(Some(crate::action::Action::Render));
                },
                'a' => {
                  self.move_cursor_right();
                  self.mode = crate::editor_common::Mode::Insert;
                  return Ok(Some(crate::action::Action::Render));
                },
                'A' => {
                  self.move_cursor_to_line_end();
                  self.mode = crate::editor_common::Mode::Insert;
                  return Ok(Some(crate::action::Action::Render));
                },
                'o' => {
                  self.move_cursor_to_line_end();
                  self.insert_char('\n');
                  self.mode = crate::editor_common::Mode::Insert;
                  return Ok(Some(crate::action::Action::Render));
                },
                'O' => {
                  self.move_cursor_to_line_start();
                  self.insert_char('\n');
                  self.move_cursor_up();
                  self.mode = crate::editor_common::Mode::Insert;
                  return Ok(Some(crate::action::Action::Render));
                },

                // Edit commands
                'x' => {
                  self.delete_char_at_cursor();
                  return Ok(Some(crate::action::Action::Render));
                },
                'X' => {
                  self.delete_char_before_cursor();
                  return Ok(Some(crate::action::Action::Render));
                },
                'd' => {
                  // Simple 'dd' for delete line (would need better state management for real vim)
                  self.delete_current_line();
                  return Ok(Some(crate::action::Action::Render));
                },

                // Visual mode
                'v' => {
                  self.mode = crate::editor_common::Mode::Visual;
                  self.visual_start_pos = Some(self.cursor_pos);
                  return Ok(Some(crate::action::Action::Render));
                },

                _ => {
                  // Unknown command, ignore
                  return Ok(None);
                },
              }
            },
          }
        }

        // Handle non-character keys
        match key.code {
          // Arrow key movement
          crossterm::event::KeyCode::Left => {
            self.move_cursor_left();
            self.pending_command.clear();
            return Ok(Some(crate::action::Action::Render));
          },
          crossterm::event::KeyCode::Right => {
            self.move_cursor_right();
            self.pending_command.clear();
            return Ok(Some(crate::action::Action::Render));
          },
          crossterm::event::KeyCode::Down => {
            self.move_cursor_down();
            self.pending_command.clear();
            return Ok(Some(crate::action::Action::Render));
          },
          crossterm::event::KeyCode::Up => {
            self.move_cursor_up();
            self.pending_command.clear();
            return Ok(Some(crate::action::Action::Render));
          },

          // Escape key - clear pending commands
          crossterm::event::KeyCode::Esc => {
            self.pending_command.clear();
            return Ok(None);
          },

          // Execute query
          crossterm::event::KeyCode::Enter => {
            self.pending_command.clear();
            let query_text = self.content.trim();
            if !query_text.is_empty() {
              return Ok(Some(crate::action::Action::HandleQuery(query_text.to_string())));
            }
            return Ok(None);
          },
          _ => {
            // Clear pending command for unrecognized keys
            self.pending_command.clear();
          },
        }
      },
      crate::editor_common::Mode::Insert => {
        match key.code {
          crossterm::event::KeyCode::Esc => {
            self.mode = crate::editor_common::Mode::Normal;
            self.pending_command.clear();
            // Move cursor back one position in normal mode (vim behavior)
            if self.cursor_pos > 0 {
              self.cursor_pos -= 1;
            }
            return Ok(Some(crate::action::Action::Render));
          },
          crossterm::event::KeyCode::Char(c) => {
            // Handle control key combinations first (before inserting characters)
            if key.modifiers.contains(crossterm::event::KeyModifiers::CONTROL) {
              match c {
                'y' => {
                  // Ctrl+Y should execute query, not insert 'y'
                  // If in visual mode with selection, execute only selected text
                  let query_text = if self.mode == crate::editor_common::Mode::Visual && self.visual_start_pos.is_some()
                  {
                    let visual_start = self.visual_start_pos.unwrap();
                    let safe_cursor_pos = self.cursor_pos.min(self.content.len());
                    let selection_start = visual_start.min(safe_cursor_pos);
                    let selection_end = visual_start.max(safe_cursor_pos);

                    if selection_start < selection_end && selection_end <= self.content.len() {
                      self.content[selection_start..selection_end].to_string()
                    } else {
                      self.content.trim().to_string()
                    }
                  } else {
                    self.content.trim().to_string()
                  };

                  if !query_text.is_empty() {
                    return Ok(Some(crate::action::Action::HandleQuery(query_text)));
                  }
                  return Ok(None);
                },
                'e' => {
                  // Ctrl+E should also execute query (alternative binding)
                  let query_text = self.content.trim();
                  if !query_text.is_empty() {
                    return Ok(Some(crate::action::Action::HandleQuery(query_text.to_string())));
                  }
                  return Ok(None);
                },
                _ => {
                  // Other control characters - don't insert them as regular characters
                  return Ok(None);
                },
              }
            }

            // Regular character insertion (no control modifier)
            self.insert_char(c);
            return Ok(Some(crate::action::Action::Render));
          },
          crossterm::event::KeyCode::Backspace => {
            self.delete_char();
            return Ok(Some(crate::action::Action::Render));
          },
          crossterm::event::KeyCode::Enter => {
            // Handle Ctrl+Enter for query execution
            if key.modifiers.contains(crossterm::event::KeyModifiers::CONTROL) {
              let query_text = self.content.trim();
              if !query_text.is_empty() {
                return Ok(Some(crate::action::Action::HandleQuery(query_text.to_string())));
              }
              return Ok(None);
            }

            // Regular Enter - insert newline
            self.insert_char('\n');
            return Ok(Some(crate::action::Action::Render));
          },
          crossterm::event::KeyCode::Tab => {
            self.insert_char('\t');
            return Ok(Some(crate::action::Action::Render));
          },
          crossterm::event::KeyCode::Left => {
            self.move_cursor_left();
            return Ok(Some(crate::action::Action::Render));
          },
          crossterm::event::KeyCode::Right => {
            self.move_cursor_right();
            return Ok(Some(crate::action::Action::Render));
          },
          crossterm::event::KeyCode::Up => {
            self.move_cursor_up();
            return Ok(Some(crate::action::Action::Render));
          },
          crossterm::event::KeyCode::Down => {
            self.move_cursor_down();
            return Ok(Some(crate::action::Action::Render));
          },
          _ => {},
        }
      },
      crate::editor_common::Mode::Visual => {
        match key.code {
          crossterm::event::KeyCode::Esc => {
            self.mode = crate::editor_common::Mode::Normal;
            self.visual_start_pos = None;
            self.pending_command.clear();
            return Ok(Some(crate::action::Action::Render));
          },
          // Visual mode navigation with full vim support
          crossterm::event::KeyCode::Char('0') => {
            self.move_cursor_to_line_start();
            return Ok(Some(crate::action::Action::Render));
          },
          crossterm::event::KeyCode::Char('$') => {
            self.move_cursor_to_line_end();
            return Ok(Some(crate::action::Action::Render));
          },
          crossterm::event::KeyCode::Char('h') | crossterm::event::KeyCode::Left => {
            self.move_cursor_left();
            return Ok(Some(crate::action::Action::Render));
          },
          crossterm::event::KeyCode::Char('l') | crossterm::event::KeyCode::Right => {
            self.move_cursor_right();
            return Ok(Some(crate::action::Action::Render));
          },
          crossterm::event::KeyCode::Char('j') | crossterm::event::KeyCode::Down => {
            self.move_cursor_down();
            return Ok(Some(crate::action::Action::Render));
          },
          crossterm::event::KeyCode::Char('k') | crossterm::event::KeyCode::Up => {
            self.move_cursor_up();
            return Ok(Some(crate::action::Action::Render));
          },
          crossterm::event::KeyCode::Char('w') => {
            self.move_cursor_word_forward();
            return Ok(Some(crate::action::Action::Render));
          },
          crossterm::event::KeyCode::Char('b') => {
            self.move_cursor_word_backward();
            return Ok(Some(crate::action::Action::Render));
          },
          crossterm::event::KeyCode::Char('g') => {
            self.cursor_pos = 0;
            return Ok(Some(crate::action::Action::Render));
          },
          crossterm::event::KeyCode::Char('G') => {
            self.cursor_pos = self.content.len();
            return Ok(Some(crate::action::Action::Render));
          },
          _ => {},
        }
      },
      _ => {},
    }

    // Fallback to original Zep key handling for unhandled keys
    let (key_code, modifiers) = match key.code {
      crossterm::event::KeyCode::Char(c) => {
        let mut mods = 0u32;
        if key.modifiers.contains(crossterm::event::KeyModifiers::CONTROL) {
          mods |= 1;
        }
        if key.modifiers.contains(crossterm::event::KeyModifiers::ALT) {
          mods |= 2;
        }
        if key.modifiers.contains(crossterm::event::KeyModifiers::SHIFT) {
          mods |= 4;
        }
        (c as u32, mods)
      },
      crossterm::event::KeyCode::Enter => (13, 0),
      crossterm::event::KeyCode::Backspace => (8, 0),
      crossterm::event::KeyCode::Delete => (127, 0),
      crossterm::event::KeyCode::Esc => (27, 0),
      crossterm::event::KeyCode::Tab => (9, 0),
      crossterm::event::KeyCode::Up => (1000, 0),
      crossterm::event::KeyCode::Down => (1001, 0),
      crossterm::event::KeyCode::Left => (1002, 0),
      crossterm::event::KeyCode::Right => (1003, 0),
      _ => return Ok(None),
    };

    // Skip Zep key handling for now since we're using our own vim implementation
    // to avoid the stub text issue
    // unsafe {
    //   let handled = zep_handle_key(self.editor_ptr, key_code, modifiers);
    //   if handled {
    //     self.update_content_from_zep();
    //   }
    // }

    Ok(None)
  }

  fn draw(&mut self, f: &mut ratatui::Frame, area: Rect) {
    self.draw_with_focus(f, area, false); // Default to not focused
  }

  fn draw_with_focus(&mut self, f: &mut ratatui::Frame, area: Rect, _is_focused: bool) {
    // For now, we'll create a placeholder widget since we need to integrate with ImGui
    // This is where we would render the Zep editor using ImGui backend
    // In a real implementation, this would require more complex integration

    unsafe {
      zep_display(self.editor_ptr, area.x as f32, area.y as f32, area.width as f32, area.height as f32);
    }

    // Create a placeholder text widget showing that Zep editor is active
    use ratatui::{
      text::Text,
      widgets::{Block, Borders, Paragraph},
    };

    // Show content with cursor position for the stub implementation
    let mode_str = match self.mode {
      crate::editor_common::Mode::Normal => "NORMAL",
      crate::editor_common::Mode::Insert => "INSERT",
      crate::editor_common::Mode::Visual => "VISUAL",
      _ => "UNKNOWN",
    };

    let safe_cursor_pos = self.cursor_pos.min(self.content.len());
    let cursor_line = self.content[..safe_cursor_pos].matches('\n').count() + 1;
    let line_start = self.get_current_line_start();
    let cursor_col = safe_cursor_pos.saturating_sub(line_start) + 1;

    // Create styled content using Ratatui spans for proper highlighting
    let content_text = if self.content.is_empty() {
      // Empty editor with line numbers
      use ratatui::text::{Line, Span};

      let mut lines = Vec::new();
      for i in 1..=20 {
        lines.push(Line::from(vec![
          Span::styled(format!("{:3}", i), crate::theme::Theme::line_numbers()),
          Span::raw(" "),
        ]));
      }
      Text::from(lines)
    } else {
      // Create content with proper syntax highlighting for visual selection
      use ratatui::{
        style::Modifier,
        text::{Line, Span},
      };

      let content_lines: Vec<&str> = self.content.lines().collect();
      let mut display_lines = Vec::new();
      let mut current_pos = 0;
      let mut cursor_inserted = false;

      // Get selection range if in visual mode
      let selection_range = if self.mode == crate::editor_common::Mode::Visual && self.visual_start_pos.is_some() {
        let visual_start = self.visual_start_pos.unwrap();
        let selection_start = visual_start.min(safe_cursor_pos);
        let selection_end = visual_start.max(safe_cursor_pos);
        Some((selection_start, selection_end))
      } else {
        None
      };

      for (line_num, line_content) in content_lines.iter().enumerate() {
        let line_start = current_pos;
        let line_end = current_pos + line_content.len();

        let mut line_spans = Vec::new();

        // Add line number with professional styling
        line_spans.push(Span::styled(format!("{:3}", line_num + 1), crate::theme::Theme::line_numbers()));
        line_spans.push(Span::raw(" "));

        // Handle line content with selection highlighting
        if let Some((sel_start, sel_end)) = selection_range {
          if sel_start <= line_end && sel_end >= line_start {
            // This line has selection
            let line_sel_start = sel_start.saturating_sub(line_start).min(line_content.len());
            let line_sel_end = sel_end.saturating_sub(line_start).min(line_content.len());

            // Before selection
            if line_sel_start > 0 {
              line_spans.push(Span::raw(&line_content[..line_sel_start]));
            }

            // Selected text with highlighting
            if line_sel_start < line_sel_end {
              line_spans.push(Span::styled(
                &line_content[line_sel_start..line_sel_end],
                crate::theme::Theme::selection_active(),
              ));
            }

            // After selection
            if line_sel_end < line_content.len() {
              line_spans.push(Span::raw(&line_content[line_sel_end..]));
            }
          } else {
            // No selection on this line - apply syntax highlighting
            line_spans.extend(self.apply_syntax_highlighting(line_content));
          }
        } else {
          // Not in visual mode - apply syntax highlighting
          line_spans.extend(self.apply_syntax_highlighting(line_content));
        }

        // Add cursor if it's on this line
        if !cursor_inserted && safe_cursor_pos >= line_start && safe_cursor_pos <= line_end {
          let cursor_pos_in_line = safe_cursor_pos - line_start;
          // In normal mode, cursor should show the character it's over
          let (cursor_char, _cursor_bg_char) = match self.mode {
            crate::editor_common::Mode::Normal => {
              let char_under_cursor = if cursor_pos_in_line < line_content.len() {
                line_content.chars().nth(cursor_pos_in_line).unwrap_or(' ')
              } else {
                ' '
              };
              (char_under_cursor, Some(char_under_cursor))
            },
            crate::editor_common::Mode::Insert => ('│', None),
            crate::editor_common::Mode::Visual => {
              let char_under_cursor = if cursor_pos_in_line < line_content.len() {
                line_content.chars().nth(cursor_pos_in_line).unwrap_or(' ')
              } else {
                ' '
              };
              (char_under_cursor, Some(char_under_cursor))
            },
            _ => ('█', None),
          };

          // Insert cursor at the right position within the spans
          if cursor_pos_in_line <= line_content.len() {
            // Find which span the cursor belongs to and split it
            let mut char_count = 0;
            let line_number_len = 5; // "   1 " format

            for (span_idx, span) in line_spans.iter_mut().enumerate().skip(1) {
              // Skip line number span
              let span_len = span.content.len();
              if char_count + span_len >= cursor_pos_in_line {
                let pos_in_span = cursor_pos_in_line - char_count;
                let span_content = span.content.to_string();

                // Split the span and insert cursor
                let before = &span_content[..pos_in_span];
                let after = &span_content[pos_in_span..];

                // Replace current span with before + cursor + after
                let span_style = span.style;
                line_spans[span_idx] = Span::styled(before.to_string(), span_style);

                // Insert cursor span with mode-specific styling
                let cursor_style = match self.mode {
                  crate::editor_common::Mode::Normal => crate::theme::Theme::cursor_normal(),
                  crate::editor_common::Mode::Insert => crate::theme::Theme::cursor_insert(),
                  crate::editor_common::Mode::Visual => crate::theme::Theme::cursor_visual(),
                  _ => crate::theme::Theme::cursor_normal(),
                };

                // Handle cursor rendering based on mode
                if self.mode == crate::editor_common::Mode::Insert {
                  // For insert mode, highlight the character to the right of cursor position
                  // This simulates the cursor being "between" characters
                  line_spans[span_idx] = Span::styled(before.to_string(), span_style);

                  if pos_in_span < span_content.len() {
                    // There's a character at cursor position - highlight it with green background
                    let char_at_cursor = span_content.chars().nth(pos_in_span).unwrap();
                    line_spans.insert(
                      span_idx + 1,
                      Span::styled(
                        char_at_cursor.to_string(),
                        span_style.bg(crate::theme::Theme::ACCENT_GREEN), // Theme green for insert cursor
                      ),
                    );

                    // Add the rest of the text after cursor
                    let after_cursor: String = span_content.chars().skip(pos_in_span + 1).collect();
                    if !after_cursor.is_empty() {
                      line_spans.insert(span_idx + 2, Span::styled(after_cursor, span_style));
                    }
                  } else {
                    // Cursor at end of line - show a pipe character
                    line_spans.insert(span_idx + 1, Span::styled("│".to_string(), cursor_style));
                  }
                } else {
                  // For normal/visual mode, replace the character with highlighted version
                  line_spans[span_idx] = Span::styled(before.to_string(), span_style);
                  line_spans.insert(span_idx + 1, Span::styled(cursor_char.to_string(), cursor_style));

                  // Skip the character under cursor for normal/visual mode by adjusting after
                  if !after.is_empty() {
                    let after_chars: Vec<char> = after.chars().collect();
                    if after_chars.len() > 1 {
                      line_spans
                        .insert(span_idx + 2, Span::styled(after_chars[1..].iter().collect::<String>(), span_style));
                    }
                  }
                }

                cursor_inserted = true;
                break;
              }
              char_count += span_len;
            }

            // If cursor is at the end of the line
            if !cursor_inserted && cursor_pos_in_line == line_content.len() {
              let cursor_style = match self.mode {
                crate::editor_common::Mode::Normal => crate::theme::Theme::cursor_normal(),
                crate::editor_common::Mode::Insert => crate::theme::Theme::cursor_insert(),
                crate::editor_common::Mode::Visual => crate::theme::Theme::cursor_visual(),
                _ => crate::theme::Theme::cursor_normal(),
              };

              let cursor_display = if self.mode == crate::editor_common::Mode::Insert {
                "│" // Always pipe for insert mode
              } else {
                &cursor_char.to_string()
              };

              line_spans.push(Span::styled(cursor_display.to_string(), cursor_style));
              cursor_inserted = true;
            }
          }
        }

        display_lines.push(Line::from(line_spans));
        current_pos = line_end + 1;
      }

      // Add cursor at end of content if not inserted yet
      if !cursor_inserted {
        let cursor_char = match self.mode {
          crate::editor_common::Mode::Normal => ' ', // Block cursor shows space when at end
          crate::editor_common::Mode::Insert => '│',
          crate::editor_common::Mode::Visual => ' ',
          _ => '█',
        };

        let cursor_style = match self.mode {
          crate::editor_common::Mode::Normal => crate::theme::Theme::cursor_normal(),
          crate::editor_common::Mode::Insert => crate::theme::Theme::cursor_insert(),
          crate::editor_common::Mode::Visual => crate::theme::Theme::cursor_visual(),
          _ => crate::theme::Theme::cursor_normal(),
        };

        if display_lines.is_empty() {
          display_lines.push(Line::from(vec![
            Span::styled("  1", crate::theme::Theme::line_numbers()),
            Span::raw(" "),
            Span::styled(cursor_char.to_string(), cursor_style),
          ]));
        } else {
          let last_idx = display_lines.len() - 1;
          display_lines[last_idx].spans.push(Span::styled(cursor_char.to_string(), cursor_style));
        }
      }

      // Add empty lines for consistent display (reserve space for status bar)
      let max_lines = (area.height as usize).saturating_sub(2);
      while display_lines.len() < max_lines {
        display_lines.push(Line::from(vec![
          Span::styled(format!("{:3}", display_lines.len() + 1), crate::theme::Theme::line_numbers()),
          Span::raw(" "),
        ]));
      }

      Text::from(display_lines)
    };

    // Create a clean, professional editor interface matching Zep's dark theme
    use ratatui::layout::{Constraint, Direction, Layout};

    // Split area to ensure status bar is always visible
    let chunks = Layout::default()
      .direction(Direction::Vertical)
      .constraints([
        Constraint::Min(1),    // Editor content
        Constraint::Length(1), // Status bar
      ])
      .split(area);

    // Render main content
    let editor_content = Paragraph::new(content_text).style(crate::theme::Theme::bg_primary());

    f.render_widget(editor_content, chunks[0]);

    // Render status bar separately at the bottom
    let status_text = {
      use ratatui::{
        style::{Modifier, Style},
        text::{Line, Span},
      };

      let pending_cmd_str =
        if !self.pending_command.is_empty() { format!(" [{}]", self.pending_command) } else { String::new() };

      let mode_style = match self.mode {
        crate::editor_common::Mode::Normal => {
          Style::default()
            .bg(crate::theme::Theme::ACCENT_BLUE)
            .fg(crate::theme::Theme::BG_PRIMARY)
            .add_modifier(Modifier::BOLD)
        },
        crate::editor_common::Mode::Insert => {
          Style::default()
            .bg(crate::theme::Theme::ACCENT_GREEN)
            .fg(crate::theme::Theme::BG_PRIMARY)
            .add_modifier(Modifier::BOLD)
        },
        crate::editor_common::Mode::Visual => {
          Style::default()
            .bg(crate::theme::Theme::ACCENT_PURPLE)
            .fg(crate::theme::Theme::BG_PRIMARY)
            .add_modifier(Modifier::BOLD)
        },
        _ => {
          Style::default()
            .bg(crate::theme::Theme::FG_SECONDARY)
            .fg(crate::theme::Theme::FG_PRIMARY)
            .add_modifier(Modifier::BOLD)
        },
      };

      let mut status_spans = vec![Span::styled(format!(" {} ", mode_str), mode_style)];

      if !pending_cmd_str.is_empty() {
        status_spans.push(Span::styled(pending_cmd_str, crate::theme::Theme::warning()));
      }

      status_spans.push(Span::styled(format!("  {}:{}", cursor_line, cursor_col), crate::theme::Theme::info()));

      if self.mode == crate::editor_common::Mode::Visual && self.visual_start_pos.is_some() {
        let visual_start = self.visual_start_pos.unwrap();
        let selection_start = visual_start.min(safe_cursor_pos);
        let selection_end = visual_start.max(safe_cursor_pos);
        let selected_chars = selection_end.saturating_sub(selection_start);
        status_spans.push(Span::styled(
          format!(" ({} selected)", selected_chars),
          Style::default().fg(crate::theme::Theme::ACCENT_PURPLE),
        ));
      }

      Line::from(status_spans)
    };

    let status_bar = Paragraph::new(status_text).style(crate::theme::Theme::status_bar());

    f.render_widget(status_bar, chunks[1]);
  }

  fn get_text(&self) -> String {
    self.content.clone()
  }

  fn get_selected_text(&self) -> Option<String> {
    None
  }

  fn set_text(&mut self, text: &str) {
    self.content = text.to_string();
    self.cursor_pos = self.content.len(); // Move cursor to end

    // Update Zep editor with new text
    let name = CString::new("query").expect("Failed to create buffer name");
    let text_cstring = CString::new(text).expect("Failed to create text CString");

    unsafe {
      zep_init_with_text(self.editor_ptr, name.as_ptr(), text_cstring.as_ptr());
    }
  }

  fn as_any(&self) -> &dyn std::any::Any {
    self
  }

  fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
    self
  }
}

#[cfg(feature = "zep-editor")]
impl ZepEditor {
  // Additional methods for EditorBackend compatibility
  pub fn mode(&self) -> crate::editor_common::Mode {
    self.mode
  }
}

// Provide a stub implementation when the feature is not enabled
#[cfg(not(feature = "zep-editor"))]
#[derive(Debug)]
pub struct ZepEditor;

#[cfg(not(feature = "zep-editor"))]
impl Default for ZepEditor {
  fn default() -> Self {
    Self
  }
}

#[cfg(not(feature = "zep-editor"))]
impl ZepEditor {
  pub fn mode(&self) -> crate::editor_common::Mode {
    crate::editor_common::Mode::Normal
  }
}

#[cfg(not(feature = "zep-editor"))]
use color_eyre::eyre::Result;
#[cfg(not(feature = "zep-editor"))]
use crossterm::event::KeyEvent;
#[cfg(not(feature = "zep-editor"))]
use ratatui::layout::Rect;

#[cfg(not(feature = "zep-editor"))]
use crate::{action::Action, editor_component::EditorComponent};

#[cfg(feature = "zep-editor")]
#[cfg(test)]
mod tests {
  use crossterm::event::{KeyCode, KeyEvent, KeyModifiers};
  use ratatui::layout::Rect;

  use super::*;

  #[test]
  fn test_zep_editor_creation() {
    let editor = ZepEditor::new();
    assert_eq!(editor.mode, crate::editor_common::Mode::Normal);
    assert_eq!(editor.cursor_pos, 0);
    assert!(editor.content.is_empty());
  }

  #[test]
  fn test_zep_editor_set_text() {
    let mut editor = ZepEditor::new();
    let test_text = "SELECT * FROM users;\nWHERE id = 1;";

    editor.set_text(test_text);

    assert_eq!(editor.get_text(), test_text);
    assert_eq!(editor.cursor_pos, test_text.len());
  }

  #[test]
  fn test_vim_mode_switching() {
    let mut editor = ZepEditor::new();

    // Start in normal mode
    assert_eq!(editor.mode, crate::editor_common::Mode::Normal);

    // Switch to insert mode
    let key = KeyEvent::new(KeyCode::Char('i'), KeyModifiers::NONE);
    let result = editor.on_key_event(key).unwrap();
    assert!(result.is_some());
    assert_eq!(editor.mode, crate::editor_common::Mode::Insert);

    // Switch back to normal mode
    let key = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
    let result = editor.on_key_event(key).unwrap();
    assert!(result.is_some());
    assert_eq!(editor.mode, crate::editor_common::Mode::Normal);
  }

  #[test]
  fn test_no_stub_text_insertion() {
    let mut editor = ZepEditor::new();
    let initial_text = "SELECT * FROM test;";
    editor.set_text(initial_text);

    // The content should remain as set, not be overwritten by stub text
    assert_eq!(editor.get_text(), initial_text);
    assert!(!editor.get_text().contains("stub implementation"));
    assert!(!editor.get_text().contains("Zep Editor (stub"));
  }

  #[test]
  fn test_cc_command_change_line() {
    let mut editor = ZepEditor::new();
    editor.set_text("SELECT * FROM users;\nWHERE id = 1;");
    editor.cursor_pos = 5; // Position in first line

    // Simulate "cc" command
    let key1 = KeyEvent::new(KeyCode::Char('c'), KeyModifiers::NONE);
    let result1 = editor.on_key_event(key1).unwrap();
    assert!(result1.is_none()); // First 'c' should wait for second
    assert_eq!(editor.pending_command, "c");

    let key2 = KeyEvent::new(KeyCode::Char('c'), KeyModifiers::NONE);
    let result2 = editor.on_key_event(key2).unwrap();
    assert!(result2.is_some()); // Second 'c' should trigger action
    assert_eq!(editor.mode, crate::editor_common::Mode::Insert);
    assert_eq!(editor.get_text(), "\nWHERE id = 1;"); // First line should be cleared
    assert!(editor.pending_command.is_empty());
  }

  #[test]
  fn test_gcc_command_toggle_comment() {
    let mut editor = ZepEditor::new();
    editor.set_text("SELECT * FROM users;\nWHERE id = 1;");
    editor.cursor_pos = 5; // Position in first line

    // Simulate "gcc" command to add comment
    let key1 = KeyEvent::new(KeyCode::Char('g'), KeyModifiers::NONE);
    let result1 = editor.on_key_event(key1).unwrap();
    assert!(result1.is_none()); // First 'g' should wait

    let key2 = KeyEvent::new(KeyCode::Char('c'), KeyModifiers::NONE);
    let result2 = editor.on_key_event(key2).unwrap();
    assert!(result2.is_none()); // Second char should wait

    let key3 = KeyEvent::new(KeyCode::Char('c'), KeyModifiers::NONE);
    let result3 = editor.on_key_event(key3).unwrap();
    assert!(result3.is_some()); // Third char should trigger action

    assert_eq!(editor.get_text(), "-- SELECT * FROM users;\nWHERE id = 1;");
    assert!(editor.pending_command.is_empty());

    // Test uncomment by running gcc again
    let key1 = KeyEvent::new(KeyCode::Char('g'), KeyModifiers::NONE);
    editor.on_key_event(key1).unwrap();
    let key2 = KeyEvent::new(KeyCode::Char('c'), KeyModifiers::NONE);
    editor.on_key_event(key2).unwrap();
    let key3 = KeyEvent::new(KeyCode::Char('c'), KeyModifiers::NONE);
    editor.on_key_event(key3).unwrap();

    assert_eq!(editor.get_text(), "SELECT * FROM users;\nWHERE id = 1;");
  }

  #[test]
  fn test_pending_command_display() {
    let mut editor = ZepEditor::new();
    editor.set_text("SELECT * FROM test;");

    // Check that pending command shows in status
    let key = KeyEvent::new(KeyCode::Char('c'), KeyModifiers::NONE);
    editor.on_key_event(key).unwrap();
    assert_eq!(editor.pending_command, "c");

    // Pending command should be cleared by escape
    let esc_key = KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE);
    editor.on_key_event(esc_key).unwrap();
    assert!(editor.pending_command.is_empty());
  }

  #[test]
  fn test_ctrl_y_in_insert_mode_no_extra_y() {
    let mut editor = ZepEditor::new();
    editor.set_text("SELECT * FROM test");
    editor.mode = crate::editor_common::Mode::Insert;
    editor.cursor_pos = editor.content.len();

    // Simulate Ctrl+Y in insert mode
    let ctrl_y_key = KeyEvent::new(KeyCode::Char('y'), KeyModifiers::CONTROL);
    let result = editor.on_key_event(ctrl_y_key).unwrap();

    // Should execute query, not insert 'y'
    assert!(matches!(result, Some(crate::action::Action::HandleQuery(_))));
    assert_eq!(editor.get_text(), "SELECT * FROM test"); // No extra 'y' inserted

    if let Some(crate::action::Action::HandleQuery(query)) = result {
      assert_eq!(query, "SELECT * FROM test");
    }
  }

  #[test]
  fn test_ctrl_e_in_insert_mode() {
    let mut editor = ZepEditor::new();
    editor.set_text("SELECT * FROM users");
    editor.mode = crate::editor_common::Mode::Insert;

    // Simulate Ctrl+E in insert mode
    let ctrl_e_key = KeyEvent::new(KeyCode::Char('e'), KeyModifiers::CONTROL);
    let result = editor.on_key_event(ctrl_e_key).unwrap();

    // Should execute query
    assert!(matches!(result, Some(crate::action::Action::HandleQuery(_))));
    assert_eq!(editor.get_text(), "SELECT * FROM users"); // No extra 'e' inserted
  }

  #[test]
  fn test_ctrl_enter_in_insert_mode() {
    let mut editor = ZepEditor::new();
    editor.set_text("SELECT 1");
    editor.mode = crate::editor_common::Mode::Insert;

    // Simulate Ctrl+Enter in insert mode
    let ctrl_enter_key = KeyEvent::new(KeyCode::Enter, KeyModifiers::CONTROL);
    let result = editor.on_key_event(ctrl_enter_key).unwrap();

    // Should execute query
    assert!(matches!(result, Some(crate::action::Action::HandleQuery(_))));
    assert_eq!(editor.get_text(), "SELECT 1"); // No newline inserted
  }

  #[test]
  fn test_regular_y_still_works_in_insert_mode() {
    let mut editor = ZepEditor::new();
    editor.set_text("m");
    editor.mode = crate::editor_common::Mode::Insert;
    editor.cursor_pos = 1;

    // Simulate regular 'y' (no control modifier) in insert mode
    let y_key = KeyEvent::new(KeyCode::Char('y'), KeyModifiers::NONE);
    let result = editor.on_key_event(y_key).unwrap();

    // Should insert 'y' normally
    assert!(matches!(result, Some(crate::action::Action::Render)));
    assert_eq!(editor.get_text(), "my"); // 'y' should be inserted
  }
}

#[cfg(not(feature = "zep-editor"))]
impl EditorComponent for ZepEditor {
  fn init(&mut self, _area: Rect) -> Result<()> {
    Err(color_eyre::eyre::eyre!("Zep editor not compiled - enable 'zep-editor' feature"))
  }

  fn on_key_event(&mut self, _key: KeyEvent) -> Result<Option<Action>> {
    Err(color_eyre::eyre::eyre!("Zep editor not compiled - enable 'zep-editor' feature"))
  }

  fn draw(&mut self, _f: &mut ratatui::Frame, _area: Rect) {
    // No-op when feature is disabled
  }

  fn draw_with_focus(&mut self, _f: &mut ratatui::Frame, _area: Rect, _is_focused: bool) {
    // No-op when feature is disabled
  }

  fn get_text(&self) -> String {
    String::new()
  }

  fn get_selected_text(&self) -> Option<String> {
    None
  }

  fn set_text(&mut self, _text: &str) {
    // No-op when feature is disabled
  }

  fn as_any(&self) -> &dyn std::any::Any {
    self
  }

  fn as_any_mut(&mut self) -> &mut dyn std::any::Any {
    self
  }
}
